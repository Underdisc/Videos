Anim(object, path, time, duration);

References

History
https://graphics.stanford.edu/courses/cs248-02/History-of-graphics/History-of-graphics.pdf
https://deseng.ryerson.ca/dokuwiki/mec222:brief_history_of_computer_graphics
https://www.computerhistory.org/timeline/graphics-games/

https://learnopengl.com/Getting-started/Hello-Triangle
http://www.fragmentstorm.com/overview-of-the-graphics-pipeline
https://www.khronos.org/opengl/wiki/Primitive_Assembly
https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview

Vector Monitor: The image is created by drawing lines using an electron beam.
Raster Monitor: The image is created by assigning values to individual pixels.
Sketch, made by Sutherland, used a vector display.

The Fundamentals of Computer Graphics

Intro
  Hook
    Spinning Cube

[Cube expands and the first few bars of music plays]

What you're seeing here is deceivingly simple. It's just a cube rotating in some simulated 3D space. As 3D beings, it's easy to understand, but to build everything necessary to render something like this would require more work than one person could hope to accomplish on their own. And indeed, many have thrown themselves into problems involving generating images, which, in the grand scheme of things, is only a recent development.

  History

Computing in general only began to take off in the 1940s. It would take another 20 years until the idea of graphics would become of interest, and, despite its many applications, leave it up to none other than vidya games to gather it. Since Tennis-For-Two in '58 and Spacewar! in '62, we've come a very long way. Nowadays, games with graphics similar to that of 2015's Witcher 3 are commonplace. In this video, I'd like to give you an introduction to the core concepts programmers use to render images in games, movies, and even this video. Without further ado, let's talk about the fundamentals of computer graphics.

Body
  Vertices
    
Our first focus is the most fundamental element of all, the vertex. 
In the most general sense, a vertex is just a grouping of unique types of data.
These different types are referred to as attributes.
They determine the "what" of rendering and they can take many forms.
The most common attributes are position, normal, and uv.
It's important to note that attributes can really be whatever we desire, but these are the most common ways that we interpret attribute data.
Though loved by many a graphics programmer, the normal and uv attributes aren't nearly as important as position.
So we'll ignore the others and focus entirely on that.
The position attribute is usually composed of 3 values: an x, y, and z coordinate.
Collectively, these represent a vertice's location in space.
I say usually because it's also possible to use only 2 values or even 1 for the position attribute.
For the sake of uniformity, though, our position attribute will have 3 values.

This will serve as our foundation.
Our vertex type will have one attribute with 3 values that will be interpreted as a position.





Vertices
  Transformations
    Model
    Camera
    Projection
  Vertex Shader
Primitive Assembly
  The Standard Cube
  Clipping
Rasterization
  Fragments
Fragment Processing
  Fragment Shader
Fragment Testing

In the last 100 years, computational devices have created a cutural explosion. They have gone from being nonexistant to being present in almost every household in the first world. Despite existing for a century, our ability to display moving images using them began only 60ish years ago. Since then, our knowledge about computer graphics has expanded dramatically. Within the span of a single lifetime, we have gone from 2D interactive applications like Pong to the ever growing list of 3D applications we have today, some of which approach the visual fidelity we experience in the analog world.

Of course, it's not just magic, and thanks to things like the internet, understanding how our modern rendering techniques work is far from innaccessible. In this video, I'd like to take you on a little journey through the modern graphics pipeline. This will not cover the nuance of everything, but should communicate the basic ideas, even if it requires more hand waving than I am a fan of. So, without further ado, let's dive into the fundamentals of computer graphics.

Vertices

The first thing to know about is the most basic element of all 3D rendering, the vertex. It's nothing more than a point in space. If we're performing 2D rendering, a vertex is just two values, x and y. If we bring things into the third dimension, a vertex will also have a z value. Each of the values repesents how far away the point is from the origin on each axis. Using these values, we can represent any location in our imaginary 3D world. Unfortunately, as important as it might be, a lone vertex is not very interesting, and any rendering will seldom, if ever, use only a single one. Instead, we can use multiple and draw lines between them to display any shape our heart desires. There's more to this line drawing business, but we'll return to that topic later.

This is a triangle composed 3 unique vertices.
a pyramid composed of 5,
[Shrink the triangle and place it in the top left]
[Expand a pyramid in the bottom center]
[Repeat this process for every mesh]
a cube composed of 8, and a spaceship composed of N.

When vertices are grouped together like this, we refer to the collection and the lines connecting them as a mesh. What you're looking at right now is just 4 different meshes, each of which is composed of a different set of vertices.

Transformations

Once we have a mesh, the next step involves moving, scaling, and rotating that mesh within our world. These operations are called transformations and there are many more than the three I just mentioned. To give you an idea about how these transformations function, I am going to show how scaling and moving work. Unfortunately, other transformations are more involved. Some of which are even deserving of their own video, but I digress.

Let's start with scaling and what exactly I mean by that. Take, for instance, the triangle composed of three vertices we created earlier. Scaling that triangle can mean making it larger, smaller, or stretching it along one of the principal axes. The way we achieve this is by taking the three vertices that make up our triangle, performing the same operation on all three vertices, and then using the output of those three operations as the new vertices that represent our triangle. The step between the old and new vertices is where a transformation is applied. This transformation is achieved using a matrix.
